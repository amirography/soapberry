= Using gRPC for synchronous messaging
{author}
// author of this document
:author: Amir H. Alesheikh <amirhossein.alesheikh@gmail.com>
// the person proposing this idea
:proposer: {author}
// the date that this proposal was created
:date: 2023-03-10
// status of the proposal
// proposed | accepted | rejected | superseded by <example.adoc> | deprecated
:status: accepted
// the person that decides the status of the document
:decider: {author}
// people consulted for this proposal
:consulted: NONE
// decision summary
:decision: use gRPC for synchronous messaging
:description: {decision}

[cols="^0h,<1", stripes=hover,%rotate,.details]
|====
|Date | {date}
|Status| {status}
|Proposer| {proposer}
|Decider| {decider}
|consulted| {consulted}
|====


== Context
What kind of APIs should we for synchronous messaging?


== Decision drivers
// items and forces that are considered in this decision
* Speed of development
* Type-safety
* File transfer
* Ease of documentation


== Decision
// what is the change that we're proposing and/or doing?
{decision}

== Considered Alternatives
// alternatives routes we could have taken, why we did not
* RESTful
** Documentation needs external tools (such as OpenAPI)
** Does not handle streaming data well
** Even though it is ubiquitous everyone uses it differently from one another.
   Which makes it harder to learn, seeing that everyone has their own preconceived notion of how it supposed to work.

* GraphQL
** Does not offer anything over RESTful that matters to the project, but increases the complexity considerably

* Messaging queues
** messaging queues only make sense here in the context of asynchronous messaging. Which is not applicable here.


== Consequences
// What becomes easier or more difficult to do because of this change?
Pros::
* Improve ease of development and documentation
* Decrease concerns over type-safety
* Boon to the performance
* much easier to stream files and periodic data
Cons::
* limits the number of languages supported as a client
* increases complexity of working in-case a client is written in JavaScript, which needs a complex proxies, like envoy.
* different workflow from RESful and GraphQL
